package com.mqtt.demo;

import java.util.ArrayList;
import java.util.concurrent.ConcurrentHashMap;

/**
 * @ClassName ListDemo
 * @Description TODO
 * @Author wzw
 * @Date 2020/4/22 13:46
 * @Version 1.0
 **/
public class ListDemo {
    /*HashMap
    该映射通常用作装箱（存储桶）的哈希表，但是当箱太大时，
    它们将转换为TreeNode的箱，每个树的结构与java.util.TreeMap中的类似。
    大多数方法尝试使用普通的bin，但是在适用时中继到TreeNode方法（只需检查节点的instance即可）。
     TreeNodes的Bin可以像其他任何遍历一样使用，但过度填充时还支持更快的查找。
     但是，由于正常使用中的绝大多数垃圾箱都没有人口过多，因此在使用表方法的过程中，检查垃圾箱是否存在可能会延迟。
     树箱（即，频段其元素是所有树节点）都是有序主要通过的hashCode，但在并列的情况
     * ，如果两个元素是相同的“C类器具可比<C>”，类型的然后其compareTo方法用于排序。
     * （我们*通过反射保守地检查泛型类型以验证*这-参见方法compareableClassFor）。
     * 当键具有不同的哈希值或可排序时，树箱增加的复杂性值得提供最坏情况的O（log n）
     * *操作，因此，在*偶然或恶意使用hashCode（）方法*的情况下，性能会优雅降低。
     * 返回分布不佳的值，以及*中许多键共享一个hashCode的值，只要它们也是*可比较的。
     * （如果这两种方法都不适用，那么与不采取预防措施相比，我们可能会浪费*两倍的时间和空间。
     * 但是，唯一已知的情况是由于用户的不良编程习惯已经非常缓慢，因此几乎没有什么区别。
     * ）* *因为TreeNode的大小约为常规节点的两倍，
     * 所以我们*仅在垃圾箱包含足以保证使用*的节点时才使用它们（请参阅TREEIFY_THRESHOLD）。
     * 并且当它们变得太小（由于*移除或调整大小）时，它们会转换回普通纸箱。
     * 在具有良好分布的用户hashCode的用法中，很少使用树箱。
     * 理想情况下，在随机hashCodes下，bin中*节点的频率遵循Poisson分布*
      *
      * @Param
      * @return
     （http://en.wikipedia.org/wiki/Poisson_distribution），
     默认调整大小的参数约为0.5，阈值为0.75 ，尽管由于*调整粒度而差异很大。
     忽略方差，列表大小k的预期*出现次数是（exp（-0.5）* pow（0.5，k）/ * factorial（k））。
     第一个值是
     ：* * 0：0.60653066
     * 1：0.30326533 *
     * 2：0.07581633 *
     * 3：0.01263606 *
     * 4：0.00157952 *
     * 5：0.00015795 *
     * 6：0.00001316 *
     * 7：0.00000094 *
     * 8：0.00000006 *
   更多：少于十分之一百万* *树干的根通常是它的第一个节点。
   但是，*有时（当前仅在Iterator.remove上），根可能*在其他位置，
   但可以在父链接之后恢复*（方法TreeNode.root（））。
   * *所有适用的内部方法都将哈希码作为参数（通常由公共方法提供），
   * 从而允许它们彼此调用而无需重新计算用户hashCodes。
   * *大多数内部方法还接受一个“ tab”参数，通常是当前表，但是在调整大小或转换时可以是新表或旧表。
   * * *当bin列表被树化，拆分或未树化时，我们将它们保持在相同的相对访问/遍历顺序（即，字段* Node.next）中，
   * 以更好地保留局部性，并稍微简化了拆分和遍历的处理，调用* iterator.remove。当在插入时使用比较器时，
   * 为了在整个重新平衡中保持总体排序（或此处要求的接近度），我们将类和identityHashCodes作为决胜局进行比较。
   * * *子类LinkedHashMap的存在使纯树模式与树模式之间的使用和转换变得复杂。请参阅下面的*，以了解定义为在插入，
   * *删除和访问后被调用的挂钩方法，这些方法允许LinkedHashMap内部*保持独立于这些机制。
   * （这还*要求将地图实例传递给某些实用程序方法*可能会创建新的节点。）*
   * *类似于并发编程的基于SSA的编码样式有助于*避免在所有复杂的指针操作中产生别名错误。
   *
   * 默认初始容量必须是2的幂次方。
   * 1<<4  0001 -> 10000=16 2^3
   * 最大容量
   *1<<30 =1073741824
   *默认负载因子 阈值：0.75
   *
   * ArrayList
   * 默认初始容量 10
   *
   * **/
    public static void main(String[] args){
        ConcurrentHashMap cmap;
        ArrayList a;
    }

}
